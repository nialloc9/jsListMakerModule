'use strict';

const NO_NUMBERS_REGEXP = /[^\d.]/;
const REGEXP = new RegExp(
    /\{\{\s*#\s*(([^\s}]+)\s+[^}]+)\}\}([\s\S]+?)\{\{\s*\/\s*\2\s*\}\}/.source + '|' +
    /\{\{\s*<\s*([^}]+)\}\}/.source + '|' +
    /\{\{\s*(>?)\s*([^\s}]+\s+[^}]+)\}\}/.source,
    'g'
);

function moustache(partial, placeholder) {
    return function (text, render) {
        if ('string' === typeof placeholder) {
            this.moustache.extends[placeholder] = text;
            return render('{{>' + partial + '}}');
        } else if ('string' === typeof partial) {
            return render(this.moustache.extends[partial]); /* placeholder */
        }

        text = text.split('\n');
        let statement = text.shift().split(' ');
        let action = statement.shift();
        text = text.join('\n');

        if ('function' !== typeof this[action]) {
            return this[action] || '';
        }

        let deepness = 0;
        let delimiter;
        let parameters = [];
        let properties = {};
        let property;
        let string;
        let subStatement;

        statement.forEach((token) => {
            if (subStatement) {
                subStatement += ' ' + token;
                if ('(' === token[0]) {
                    deepness++;
                }
                if (')' === token[token.length - 1]) {
                    if (deepness) {
                        deepness--;
                        return;
                    }
                    let text = subStatement.substring(1, subStatement.length - 1);
                    subStatement = this.moustache.bind(this)().bind(this)(text, render);
                } else {
                    return;
                }
            } else if (string) {
                string += ' ' + token;
                if (delimiter === token[token.length - 1]) {
                    string = string.substring(1, string.length - 1);
                    delimiter = null;
                } else {
                    return;
                }
            } else {
                if (-1 !== token.indexOf('=')) {
                    token = token.split('=');
                    property = token.shift().trim();
                    token = token.join('=').trim();
                }

                if (-1 !== '\'"`'.indexOf(token[0])) {
                    if (token[0] === token[token.length - 1]) { /* Delimited string */
                        string = token.substring(1, token.length - 1);
                    } else {
                        string = token;
                        delimiter = string[0];
                        return;
                    }
                } else if ('(' === token[0]) {
                    if (')' === token[token.length - 1]) { /* Delimited subStatement */
                        subStatement = this[token.substring(1, token.length - 1).trim()];
                    } else {
                        subStatement = token;
                        return;
                    }
                }
            }

            let result = subStatement || string;

            if (!result) {
                if (!NO_NUMBERS_REGEXP.test(token)) {
                    result = token;
                } else if (0 < token.indexOf('.')) {
                    token = token.split('.');
                    result = this;
                    while (token.length) {
                        result = (result || {})[token.shift()];
                    }
                } else {
                    result = this[token];
                }
            }

            subStatement = null;
            string = null;

            if (property) {
                properties[property] = result;
                property = null;
            } else {
                parameters.push(result);
            }
        }, []);

        parameters.push(properties);
        let response = this[action].apply(this, parameters);

        if ('function' === typeof response) {
            return response.bind(this)(text, render);
        }

        return response;
    }
}

moustache.compile = function(moustache) {
    var extending = false;
    var lastIndex = REGEXP.lastIndex;
    var match;
    var mustache = '';
    var offset = 0;

    REGEXP.lastIndex = 0;

    while (match = REGEXP.exec(moustache)) {
        if (match[5] && -1 !== '#^/!&{='.indexOf(match[5][0])) {
            continue;
        }

        mustache += moustache.substring(offset, match.index);

        if (undefined !== match[1]) {
            mustache += '{{#moustache}}' + match[1].trim() + '\n' + this.compile(match[3]) + '{{/moustache}}';
        } else if (undefined !== match[4]) {
            mustache += '{{#moustache}}moustache "' + match[4].trim() + '"{{/moustache}}';
        } else if ('>' === match[5]) {
            if (extending) {
                mustache += '{{/moustache}}';
            }
            mustache += '{{#moustache}}moustache "' + match[6].trim().replace(/(\s+)/g, '"$1"') + '"\n';
            extending = true;
        } else {
            mustache += '{{#moustache}}' + match[6].trim() + '{{/moustache}}';
        }

        offset = match.index + match[0].length;
    }

    REGEXP.lastIndex = lastIndex;

    if (offset < moustache.length) {
        mustache += moustache.substring(offset);
    }

    if (extending) {
        mustache += '{{/moustache}}';
    }

    return mustache;
};

moustache.extends = {};

moustache.parse = function(template, tags) {
    moustache.mustache = moustache.mustache || require('mustache');
    return moustache.mustache.parse(moustache.compile(template), tags);
};

moustache.render = function(template, view, partials) {
    if (view) {
        view.moustache = moustache;
    }

    if (partials) {
        for (var partial in partials) {
            if (partials.hasOwnProperty(partial)) {
                partials[partial] = moustache.compile(partials[partial]);
            }
        }
    }

    moustache.mustache = moustache.mustache || require('mustache');
    return moustache.mustache.render(moustache.compile(template), view, partials);
};

module.exports = moustache;
